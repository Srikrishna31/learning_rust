use async_std::io::prelude::*;
use async_std::{net, task};

/// Unlike an ordinary function, when you call an asynchronous function, it returns immediately, before
/// the body begins execution at all. Obviously, the call's final return value hasn't been computed
/// yet; what you get is a future of its final value.
///
/// Rust automatically treats `async fn f(...) -> T` as a function that returns a future of T, not a
/// T directly.
///
/// The future returned by an async function wraps up all the information the function body will need
/// to run: the function's arguments, space for its local variables, and so on. (It's as if you'd
/// captured the call's stack frame as an ordinary Rust value.)
///
/// The future's specific type is generated automatically by the compiler, based on the function's
/// body and arguments. This type doesn't have a name; all you know about it is that it implements
/// Future<Output=R>, where R is the async function's return type. In this sense, futures of asynchronous
/// functions are like closures: closures also have anonymous types, generated by the compiler, that
/// implement the FnOnce, Fn and FnMut traits.
///
/// An `await` expression takes ownership of the future and then polls it. If it's ready, then the
/// future's final value is the value of the await expression, and execution continues. Otherwise, it
/// returns `Poll::Pending` to its own caller.
///
/// But crucially, the next poll of `cheapo_request`'s future doesn't start at the top of the function
/// again: instead, it **resumes** execution mid-function at the point where it is about to poll
/// `connect_future`. We don't progress to the rest of the async function until that future is ready.
///
/// The ability to suspend execution mid-function and then resume later is unique to async functions.
/// When an ordinary function returns, its stack frame is gone for good. Since `await` expressions
/// depend on the ability to resume, you can only use them inside async functions.
///
/// Currently, Rust doesnot yet allow traits to have asynchronous methods. Only free functions and
/// functions inherent to a specific type can be asynchronous.
async fn cheapo_request(host: &str, port: u16, path: &str) -> std::io::Result<String> {
    /// After each call that returns a future, the code says .await. Although this looks like a
    /// reference to a struct field named await, it is actually special syntax built into the language
    /// for waiting until a future is ready. An await expression evaluates to the final value of the
    /// future.
    let mut socket = net::TcpStream::connect((host, port)).await?;

    let request = format!("GET {path} HTTP/1.1\r\nHost: {host}\r\n\r\n");

    socket.write_all(request.as_bytes()).await?;
    socket.shutdown(net::Shutdown::Write)?;

    let mut response = String::new();
    socket.read_to_string(&mut response).await?;

    Ok(response)
}

/// The `spawn_local` function is an asynchronous analogue of the standard library's std::thread::spawn
/// function for starting threads:
/// * `std::thread::spawn(C)` takes a closure `C` and starts a thread running it, returning a
/// `std::thread::JoinHandle` whose `join` method waits for the thread to finish and returns whatever
/// `C` returned.
/// * `async_std::task::spawn_local(f)` takes the future f and adds it to the pool to be polled when
/// the current thread calls `block_on`. `spawn_local` returns its own `async_std::task::JoinHandle`
/// type, itself a future that you can await to retrieve `f`'s final value.
pub async fn many_requests(requests: Vec<(String, u16, String)>) -> Vec<std::io::Result<String>> {

    use async_std::task;

    let mut handles = vec![];
    for (host, port, path) in requests {
        handles.push(task::spawn_local(cheapo_owning_request(host, port, path)));
    }

    let mut results = vec![];
    for handle in handles {
        results.push(handle.await);
    }

    results
}

async fn cheapo_owning_request(host: String, port: u16, path: String) -> std::io::Result<String> {
    cheapo_request(&host, port, &path).await
}

fn main() -> std::io::Result<()> {
    println!("Hello, world!");

    use async_std::task;

    let response = task::block_on(cheapo_request("example.com", 80, "/"))?;
    println!("{response}");

    let requests = vec![
        ("example.com".to_string(), 80, "/".to_string()),
        ("www.red-bean.com".to_string(), 80, "/".to_string()),
        ("en.wikipedia.org".to_string(), 80, "/".to_string()),
    ];

    let results = async_std::task::block_on(many_requests(requests));

    println!("{}", "*".repeat(50));
    for result in results {
        match result {
            Ok(response) =>  println!("{response}"),
            Err(err) =>  eprintln!("error: {err}")
        }
        println!("{}", "*".repeat(50));
    }

    Ok(())
}
