use async_std::io::prelude::*;
use async_std::{net, task};

/// Unlike an ordinary function, when you call an asynchronous function, it returns immediately, before
/// the body begins execution at all. Obviously, the call's final return value hasn't been computed
/// yet; what you get is a future of its final value.
///
/// Rust automatically treats `async fn f(...) -> T` as a function that returns a future of T, not a
/// T directly.
///
/// The future returned by an async function wraps up all the information the function body will need
/// to run: the function's arguments, space for its local variables, and so on. (It's as if you'd
/// captured the call's stack frame as an ordinary Rust value.)
///
/// The future's specific type is generated automatically by the compiler, based on the function's
/// body and arguments. This type doesn't have a name; all you know about it is that it implements
/// Future<Output=R>, where R is the async function's return type. In this sense, futures of asynchronous
/// functions are like closures: closures also have anonymous types, generated by the compiler, that
/// implement the FnOnce, Fn and FnMut traits.
///
/// An `await` expression takes ownership of the future and then polls it. If it's ready, then the
/// future's final value is the value of the await expression, and execution continues. Otherwise, it
/// returns `Poll::Pending` to its own caller.
///
/// But crucially, the next poll of `cheapo_request`'s future doesn't start at the top of the function
/// again: instead, it **resumes** execution mid-function at the point where it is about to poll
/// `connect_future`. We don't progress to the rest of the async function until that future is ready.
///
/// The ability to suspend execution mid-function and then resume later is unique to async functions.
/// When an ordinary function returns, its stack frame is gone for good. Since `await` expressions
/// depend on the ability to resume, you can only use them inside async functions.
///
/// Currently, Rust doesnot yet allow traits to have asynchronous methods. Only free functions and
/// functions inherent to a specific type can be asynchronous.
async fn cheapo_request(host: &str, port: u16, path: &str) -> std::io::Result<String> {
    /// After each call that returns a future, the code says .await. Although this looks like a
    /// reference to a struct field named await, it is actually special syntax built into the language
    /// for waiting until a future is ready. An await expression evaluates to the final value of the
    /// future.
    let mut socket = net::TcpStream::connect((host, port)).await?;

    let request = format!("GET {path} HTTP/1.1\r\nHost: {host}\r\n\r\n");

    socket.write_all(request.as_bytes()).await?;
    socket.shutdown(net::Shutdown::Write)?;

    let mut response = String::new();
    socket.read_to_string(&mut response).await?;

    Ok(response)
}

/// The `spawn_local` function is an asynchronous analogue of the standard library's std::thread::spawn
/// function for starting threads:
/// * `std::thread::spawn(C)` takes a closure `C` and starts a thread running it, returning a
/// `std::thread::JoinHandle` whose `join` method waits for the thread to finish and returns whatever
/// `C` returned.
/// * `async_std::task::spawn_local(f)` takes the future f and adds it to the pool to be polled when
/// the current thread calls `block_on`. `spawn_local` returns its own `async_std::task::JoinHandle`
/// type, itself a future that you can await to retrieve `f`'s final value.
///
/// # Async Blocks
/// In addition to asynchronous functions, Rust also supports asynchronous blocks. Whereas ordinary
/// block statement returns the value of its last expression, an async block returns a future of the
/// value of its last expression. You can use await expression within asn async block.
/// An async block looks like an ordinary block statement, preceded by the async key word.
///
/// If you apply the ? operator to an error in an async block, it just returns from the block, not
/// from the surrounding function. Similarly, return expressions return from the async block, not the
/// enclosing function.
///
/// If an async block refers to variables defined in the surrounding code, its future captures their
/// values, just as a closure would. And just like move closures, you can start the block with async
/// move to take ownership of the captured values, rather than just holding references to them.
///
/// # Spawning Async Tasks on a Thread Pool
/// Like `spawn_local`, `spawn` returns a `JoinHandle` value you can await to get the future's final
/// value. But unlike `spawn_local`, the future doesn't have to wait for you to call `block_on` before
/// it gets polled. As soon as one of the threads from the pool is fee, it will try polling it.
///
/// An async call may begin execution on one thread, block an `await` expression, and get resumed in
/// a different thread. So while it's a reasonable simplification to view an async function call as
/// a single, connected execution of code, the call may actually be carried out by many different
/// threads.
///
/// If you are using thread-local storage, it may be surprising to see the data you put there before
/// an `await` expression replaced by something entirely different afterward, because your task is now
/// being polled by a different thread from the pool. If this is a problem, you should instead use
/// *task-local storage;*
pub async fn many_requests(requests: Vec<(String, u16, String)>) -> Vec<std::io::Result<String>> {

    let mut handles = vec![];
    for (host, port, path) in requests {
        handles.push(task::spawn( async move {
            cheapo_request(&host, port, &path).await
        }));
    }

    let mut results = vec![];
    for handle in handles {
        results.push(handle.await);
    }

    results
}

/// Using a single surf::Client to make all our requests lets us reuse HTTP connections if several of
/// them are directed at the same server. And no async block is needed, since recv_string is an
/// asynchronous method that returns a Send + 'static future, we can pass its future directly to spawn.
pub async fn many_requests_surf(urls: &[String]) -> Vec<Result<String, surf::Error>> {
    let client = surf::Client::new();

    let mut handles = vec![];
    for url in urls {
        let request = client.get(&url).recv_string();
        handles.push(async_std::task::spawn(request));
    }

    let mut results = vec![];
    for handle in handles {
        results.push(handle.await);
    }

    results
}

fn main() -> std::io::Result<()> {
    println!("Hello, world!");

    let response = task::block_on(cheapo_request("example.com", 80, "/"))?;
    println!("{response}");

    let requests = vec![
        ("example.com".to_string(), 80, "/".to_string()),
        ("www.red-bean.com".to_string(), 80, "/".to_string()),
        ("en.wikipedia.org".to_string(), 80, "/".to_string()),
    ];

    let plain_reqs = &["http://example.com".to_string(),
                              "https:/www.red-bean.com".to_string(),
                              "https://en.wikipedia.org/wiki/Main_Page".to_string()];
    let results = async_std::task::block_on(many_requests_surf(plain_reqs));

    println!("{}", "*".repeat(50));
    for result in results {
        match result {
            Ok(response) =>  println!("{response}"),
            Err(err) =>  eprintln!("error: {err}")
        }
        println!("{}", "*".repeat(50));
    }

    Ok(())
}
